{"file":"kbli-CJd_M0Of.js","mappings":"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","names":["pick","_withAsyncContext","_ssrRenderList","_ssrInterpolate","displayStart","displayEnd","totalItems","_unref"],"sources":["../../../../node_modules/nuxt/dist/app/components/server-placeholder.js","../../../../node_modules/nuxt/dist/app/components/client-only.js","../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../../node_modules/nuxt/dist/app/composables/fetch.js","../../../../pages/kbli.vue"],"sourcesContent":["import { createElementBlock, defineComponent } from \"vue\";\r\nexport default defineComponent({\r\n  name: \"ServerPlaceholder\",\r\n  render() {\r\n    return createElementBlock(\"div\");\r\n  }\r\n});\r\n","import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from \"vue\";\r\nimport { isPromise } from \"@vue/shared\";\r\nimport { useNuxtApp } from \"../nuxt.js\";\r\nimport ServerPlaceholder from \"./server-placeholder.js\";\r\nimport { elToStaticVNode } from \"./utils.js\";\r\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\r\nconst STATIC_DIV = \"<div></div>\";\r\nexport default defineComponent({\r\n  name: \"ClientOnly\",\r\n  inheritAttrs: false,\r\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\r\n  ...import.meta.dev && {\r\n    slots: Object\r\n  },\r\n  setup(props, { slots, attrs }) {\r\n    const mounted = shallowRef(false);\r\n    onMounted(() => {\r\n      mounted.value = true;\r\n    });\r\n    if (import.meta.dev) {\r\n      const nuxtApp = useNuxtApp();\r\n      nuxtApp._isNuxtPageUsed = true;\r\n      nuxtApp._isNuxtLayoutUsed = true;\r\n    }\r\n    const vm = getCurrentInstance();\r\n    if (vm) {\r\n      vm._nuxtClientOnly = true;\r\n    }\r\n    provide(clientOnlySymbol, true);\r\n    return () => {\r\n      if (mounted.value) {\r\n        const vnodes = slots.default?.();\r\n        if (vnodes && vnodes.length === 1) {\r\n          return [cloneVNode(vnodes[0], attrs)];\r\n        }\r\n        return vnodes;\r\n      }\r\n      const slot = slots.fallback || slots.placeholder;\r\n      if (slot) {\r\n        return h(slot);\r\n      }\r\n      const fallbackStr = props.fallback || props.placeholder || \"\";\r\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\r\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\r\n    };\r\n  }\r\n});\r\nconst cache = /* @__PURE__ */ new WeakMap();\r\n// @__NO_SIDE_EFFECTS__\r\nexport function createClientOnly(component) {\r\n  if (import.meta.server) {\r\n    return ServerPlaceholder;\r\n  }\r\n  if (cache.has(component)) {\r\n    return cache.get(component);\r\n  }\r\n  const clone = { ...component };\r\n  if (clone.render) {\r\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\r\n      if ($setup.mounted$ ?? ctx.mounted$) {\r\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\r\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\r\n      }\r\n      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV);\r\n    };\r\n  } else {\r\n    clone.template &&= `\r\n      <template v-if=\"mounted$\">${component.template}</template>\r\n      <template v-else>${STATIC_DIV}</template>\r\n    `;\r\n  }\r\n  clone.setup = (props, ctx) => {\r\n    const nuxtApp = useNuxtApp();\r\n    const mounted$ = shallowRef(nuxtApp.isHydrating === false);\r\n    const instance = getCurrentInstance();\r\n    if (nuxtApp.isHydrating) {\r\n      const attrs = { ...instance.attrs };\r\n      const directives = extractDirectives(instance);\r\n      for (const key in attrs) {\r\n        delete instance.attrs[key];\r\n      }\r\n      onMounted(() => {\r\n        Object.assign(instance.attrs, attrs);\r\n        instance.vnode.dirs = directives;\r\n      });\r\n    }\r\n    onMounted(() => {\r\n      mounted$.value = true;\r\n    });\r\n    const setupState = component.setup?.(props, ctx) || {};\r\n    if (isPromise(setupState)) {\r\n      return Promise.resolve(setupState).then((setupState2) => {\r\n        if (typeof setupState2 !== \"function\") {\r\n          setupState2 ||= {};\r\n          setupState2.mounted$ = mounted$;\r\n          return setupState2;\r\n        }\r\n        return (...args) => {\r\n          if (mounted$.value || !nuxtApp.isHydrating) {\r\n            const res = setupState2(...args);\r\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\r\n          }\r\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\r\n        };\r\n      });\r\n    } else {\r\n      if (typeof setupState === \"function\") {\r\n        return (...args) => {\r\n          if (mounted$.value) {\r\n            const res = setupState(...args);\r\n            const attrs = clone.inheritAttrs !== false ? ctx.attrs : void 0;\r\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res, attrs) : h(res, attrs);\r\n          }\r\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\r\n        };\r\n      }\r\n      return Object.assign(setupState, { mounted$ });\r\n    }\r\n  };\r\n  cache.set(component, clone);\r\n  return clone;\r\n}\r\nfunction extractDirectives(instance) {\r\n  if (!instance || !instance.vnode.dirs) {\r\n    return null;\r\n  }\r\n  const directives = instance.vnode.dirs;\r\n  instance.vnode.dirs = null;\r\n  return directives;\r\n}\r\n","import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\r\nimport { captureStackTrace } from \"errx\";\r\nimport { debounce } from \"perfect-debounce\";\r\nimport { hash } from \"ohash\";\r\nimport { useNuxtApp } from \"../nuxt.js\";\r\nimport { toArray } from \"../utils.js\";\r\nimport { clientOnlySymbol } from \"../components/client-only.js\";\r\nimport { createError } from \"./error.js\";\r\nimport { onNuxtReady } from \"./ready.js\";\r\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\r\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\r\nexport function useAsyncData(...args) {\r\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\r\n  if (_isAutoKeyNeeded(args[0], args[1])) {\r\n    args.unshift(autoKey);\r\n  }\r\n  let [_key, _handler, options = {}] = args;\r\n  const key = computed(() => toValue(_key));\r\n  if (typeof key.value !== \"string\") {\r\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\r\n  }\r\n  if (typeof _handler !== \"function\") {\r\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\r\n  }\r\n  const nuxtApp = useNuxtApp();\r\n  options.server ??= true;\r\n  options.default ??= getDefault;\r\n  options.getCachedData ??= getDefaultCachedData;\r\n  options.lazy ??= false;\r\n  options.immediate ??= true;\r\n  options.deep ??= asyncDataDefaults.deep;\r\n  options.dedupe ??= \"cancel\";\r\n  const functionName = options._functionName || \"useAsyncData\";\r\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\r\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\r\n  }\r\n  const currentData = nuxtApp._asyncData[key.value];\r\n  if (isDev && currentData) {\r\n    const warnings = [];\r\n    const values = createHash(_handler, options);\r\n    if (values.handler !== currentData._hash?.handler) {\r\n      warnings.push(`different handler`);\r\n    }\r\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\r\n      if (values[opt] !== currentData._hash[opt]) {\r\n        warnings.push(`different \\`${opt}\\` option`);\r\n      }\r\n    }\r\n    if (currentData._default.toString() !== options.default.toString()) {\r\n      warnings.push(`different \\`default\\` value`);\r\n    }\r\n    if (options.deep && isShallow(currentData.data)) {\r\n      warnings.push(`mismatching \\`deep\\` option`);\r\n    }\r\n    if (warnings.length) {\r\n      const distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/app\");\r\n      const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\r\n      const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\r\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\r\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\r\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\r\n    }\r\n  }\r\n  const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\r\n  if (!nuxtApp._asyncData[key.value]?._init) {\r\n    initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\r\n    nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\r\n  }\r\n  const asyncData = nuxtApp._asyncData[key.value];\r\n  asyncData._deps++;\r\n  const initialFetch = () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\r\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\r\n  if (import.meta.server && fetchOnServer && options.immediate) {\r\n    const promise = initialFetch();\r\n    if (getCurrentInstance()) {\r\n      onServerPrefetch(() => promise);\r\n    } else {\r\n      nuxtApp.hook(\"app:created\", async () => {\r\n        await promise;\r\n      });\r\n    }\r\n  }\r\n  if (import.meta.client) {\r\n    let unregister = function(key2) {\r\n      const data = nuxtApp._asyncData[key2];\r\n      if (data?._deps) {\r\n        data._deps--;\r\n        if (data._deps === 0) {\r\n          data?._off();\r\n        }\r\n      }\r\n    };\r\n    const instance = getCurrentInstance();\r\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\r\n      instance.sp = [];\r\n    }\r\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\r\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\r\n    }\r\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\r\n      instance._nuxtOnBeforeMountCbs = [];\r\n      const cbs = instance._nuxtOnBeforeMountCbs;\r\n      onBeforeMount(() => {\r\n        cbs.forEach((cb) => {\r\n          cb();\r\n        });\r\n        cbs.splice(0, cbs.length);\r\n      });\r\n      onUnmounted(() => cbs.splice(0, cbs.length));\r\n    }\r\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\r\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value != null)) {\r\n      if (pendingWhenIdle) {\r\n        asyncData.pending.value = false;\r\n      }\r\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\r\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\r\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\r\n    } else if (options.immediate) {\r\n      initialFetch();\r\n    }\r\n    const hasScope = getCurrentScope();\r\n    const unsubExecute = watch([key, ...options.watch || []], ([newKey], [oldKey]) => {\r\n      if ((newKey || oldKey) && newKey !== oldKey) {\r\n        const hasRun = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\r\n        const isRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\r\n        if (oldKey) {\r\n          unregister(oldKey);\r\n        }\r\n        const initialFetchOptions2 = { cause: \"initial\", dedupe: options.dedupe };\r\n        if (!nuxtApp._asyncData[newKey]?._init) {\r\n          let value;\r\n          if (oldKey && hasRun) {\r\n            value = nuxtApp._asyncData[oldKey]?.data.value;\r\n          } else {\r\n            value = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\r\n            initialFetchOptions2.cachedData = value;\r\n          }\r\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, value);\r\n        }\r\n        nuxtApp._asyncData[newKey]._deps++;\r\n        if (options.immediate || hasRun || isRunning) {\r\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions2);\r\n        }\r\n      } else {\r\n        asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\r\n      }\r\n    }, { flush: \"sync\" });\r\n    if (hasScope) {\r\n      onScopeDispose(() => {\r\n        unsubExecute();\r\n        unregister(key.value);\r\n      });\r\n    }\r\n  }\r\n  const asyncReturn = {\r\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\r\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\r\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\r\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\r\n    refresh: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\r\n    execute: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\r\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\r\n  };\r\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\r\n  Object.assign(asyncDataPromise, asyncReturn);\r\n  return asyncDataPromise;\r\n}\r\nfunction writableComputedRef(getter) {\r\n  return computed({\r\n    get() {\r\n      return getter()?.value;\r\n    },\r\n    set(value) {\r\n      const ref2 = getter();\r\n      if (ref2) {\r\n        ref2.value = value;\r\n      }\r\n    }\r\n  });\r\n}\r\nexport function useLazyAsyncData(...args) {\r\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\r\n  if (_isAutoKeyNeeded(args[0], args[1])) {\r\n    args.unshift(autoKey);\r\n  }\r\n  const [key, handler, options = {}] = args;\r\n  if (import.meta.dev) {\r\n    options._functionName ||= \"useLazyAsyncData\";\r\n  }\r\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\r\n}\r\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\r\n  if (typeof keyOrFetcher === \"string\") {\r\n    return false;\r\n  }\r\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\r\n    return false;\r\n  }\r\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nexport function useNuxtData(key) {\r\n  const nuxtApp = useNuxtApp();\r\n  if (!(key in nuxtApp.payload.data)) {\r\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\r\n  }\r\n  if (nuxtApp._asyncData[key]) {\r\n    const data = nuxtApp._asyncData[key];\r\n    data._deps++;\r\n    if (getCurrentScope()) {\r\n      onScopeDispose(() => {\r\n        data._deps--;\r\n        if (data._deps === 0) {\r\n          data?._off();\r\n        }\r\n      });\r\n    }\r\n  }\r\n  return {\r\n    data: computed({\r\n      get() {\r\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\r\n      },\r\n      set(value) {\r\n        if (nuxtApp._asyncData[key]) {\r\n          nuxtApp._asyncData[key].data.value = value;\r\n        } else {\r\n          nuxtApp.payload.data[key] = value;\r\n        }\r\n      }\r\n    })\r\n  };\r\n}\r\nexport async function refreshNuxtData(keys) {\r\n  if (import.meta.server) {\r\n    return Promise.resolve();\r\n  }\r\n  await new Promise((resolve) => onNuxtReady(resolve));\r\n  const _keys = keys ? toArray(keys) : void 0;\r\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\r\n}\r\nexport function clearNuxtData(keys) {\r\n  const nuxtApp = useNuxtApp();\r\n  const _allKeys = Object.keys(nuxtApp.payload.data);\r\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\r\n  for (const key of _keys) {\r\n    clearNuxtDataByKey(nuxtApp, key);\r\n  }\r\n}\r\nfunction clearNuxtDataByKey(nuxtApp, key) {\r\n  if (key in nuxtApp.payload.data) {\r\n    nuxtApp.payload.data[key] = void 0;\r\n  }\r\n  if (key in nuxtApp.payload._errors) {\r\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\r\n  }\r\n  if (nuxtApp._asyncData[key]) {\r\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\r\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\r\n    if (pendingWhenIdle) {\r\n      nuxtApp._asyncData[key].pending.value = false;\r\n    }\r\n    nuxtApp._asyncData[key].status.value = \"idle\";\r\n  }\r\n  if (key in nuxtApp._asyncDataPromises) {\r\n    if (nuxtApp._asyncDataPromises[key]) {\r\n      nuxtApp._asyncDataPromises[key].cancelled = true;\r\n    }\r\n    nuxtApp._asyncDataPromises[key] = void 0;\r\n  }\r\n}\r\nfunction pick(obj, keys) {\r\n  const newObj = {};\r\n  for (const key of keys) {\r\n    newObj[key] = obj[key];\r\n  }\r\n  return newObj;\r\n}\r\nconst isDev = import.meta.dev;\r\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\r\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\r\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\r\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\r\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\r\n    if (value) {\r\n      return value;\r\n    }\r\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));\r\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\r\n    return promise;\r\n  };\r\n  const _ref = options.deep ? ref : shallowRef;\r\n  const hasCachedData = initialCachedData != null;\r\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\r\n    if (!keys || keys.includes(key)) {\r\n      await asyncData.execute({ cause: \"refresh:hook\" });\r\n    }\r\n  });\r\n  const asyncData = {\r\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\r\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\r\n    error: toRef(nuxtApp.payload._errors, key),\r\n    status: shallowRef(\"idle\"),\r\n    execute: (...args) => {\r\n      const [_opts, newValue = void 0] = args;\r\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\r\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\r\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\r\n      }\r\n      if (nuxtApp._asyncDataPromises[key]) {\r\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\r\n          return nuxtApp._asyncDataPromises[key];\r\n        }\r\n        nuxtApp._asyncDataPromises[key].cancelled = true;\r\n      }\r\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\r\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\r\n        if (cachedData != null) {\r\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\r\n          asyncData.error.value = asyncDataDefaults.errorValue;\r\n          asyncData.status.value = \"success\";\r\n          return Promise.resolve(cachedData);\r\n        }\r\n      }\r\n      if (pendingWhenIdle) {\r\n        asyncData.pending.value = true;\r\n      }\r\n      asyncData.status.value = \"pending\";\r\n      const promise = new Promise(\r\n        (resolve, reject) => {\r\n          try {\r\n            resolve(handler(nuxtApp));\r\n          } catch (err) {\r\n            reject(err);\r\n          }\r\n        }\r\n      ).then(async (_result) => {\r\n        if (promise.cancelled) {\r\n          return nuxtApp._asyncDataPromises[key];\r\n        }\r\n        let result = _result;\r\n        if (options.transform) {\r\n          result = await options.transform(_result);\r\n        }\r\n        if (options.pick) {\r\n          result = pick(result, options.pick);\r\n        }\r\n        if (import.meta.dev && import.meta.server && result == null) {\r\n          const stack = captureStackTrace();\r\n          const { source, line, column } = stack[stack.length - 1] ?? {};\r\n          const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\r\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\` or \\`null\\`) or the request may be duplicated on the client side.`);\r\n        }\r\n        nuxtApp.payload.data[key] = result;\r\n        asyncData.data.value = result;\r\n        asyncData.error.value = asyncDataDefaults.errorValue;\r\n        asyncData.status.value = \"success\";\r\n      }).catch((error) => {\r\n        if (promise.cancelled) {\r\n          return nuxtApp._asyncDataPromises[key];\r\n        }\r\n        asyncData.error.value = createError(error);\r\n        asyncData.data.value = unref(options.default());\r\n        asyncData.status.value = \"error\";\r\n      }).finally(() => {\r\n        if (promise.cancelled) {\r\n          return;\r\n        }\r\n        if (pendingWhenIdle) {\r\n          asyncData.pending.value = false;\r\n        }\r\n        delete nuxtApp._asyncDataPromises[key];\r\n      });\r\n      nuxtApp._asyncDataPromises[key] = promise;\r\n      return nuxtApp._asyncDataPromises[key];\r\n    },\r\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\r\n    _default: options.default,\r\n    _deps: 0,\r\n    _init: true,\r\n    _hash: isDev ? createHash(_handler, options) : void 0,\r\n    _off: () => {\r\n      unsubRefreshAsyncData();\r\n      if (nuxtApp._asyncData[key]?._init) {\r\n        nuxtApp._asyncData[key]._init = false;\r\n      }\r\n      if (purgeCachedData && !hasCustomGetCachedData) {\r\n        nextTick(() => {\r\n          if (!nuxtApp._asyncData[key]?._init) {\r\n            clearNuxtDataByKey(nuxtApp, key);\r\n            asyncData.execute = () => Promise.resolve();\r\n            asyncData.data.value = asyncDataDefaults.value;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n  return asyncData;\r\n}\r\nconst getDefault = () => asyncDataDefaults.value;\r\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\r\n  if (nuxtApp.isHydrating) {\r\n    return nuxtApp.payload.data[key];\r\n  }\r\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\r\n    return nuxtApp.static.data[key];\r\n  }\r\n};\r\nfunction createHash(_handler, options) {\r\n  return {\r\n    handler: hash(_handler),\r\n    transform: options.transform ? hash(options.transform) : void 0,\r\n    pick: options.pick ? hash(options.pick) : void 0,\r\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\r\n  };\r\n}\r\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\r\nimport { computed, getCurrentInstance, ref } from \"vue\";\r\nimport { useNuxtApp } from \"../nuxt.js\";\r\nimport { toArray } from \"../utils.js\";\r\nimport { useHead } from \"./head.js\";\r\nexport function useRequestEvent(nuxtApp) {\r\n  if (import.meta.client) {\r\n    return;\r\n  }\r\n  nuxtApp ||= useNuxtApp();\r\n  return nuxtApp.ssrContext?.event;\r\n}\r\nexport function useRequestHeaders(include) {\r\n  if (import.meta.client) {\r\n    return {};\r\n  }\r\n  const event = useRequestEvent();\r\n  const _headers = event ? getRequestHeaders(event) : {};\r\n  if (!include || !event) {\r\n    return _headers;\r\n  }\r\n  const headers = /* @__PURE__ */ Object.create(null);\r\n  for (const _key of include) {\r\n    const key = _key.toLowerCase();\r\n    const header = _headers[key];\r\n    if (header) {\r\n      headers[key] = header;\r\n    }\r\n  }\r\n  return headers;\r\n}\r\nexport function useRequestHeader(header) {\r\n  if (import.meta.client) {\r\n    return void 0;\r\n  }\r\n  const event = useRequestEvent();\r\n  return event ? getRequestHeader(event, header) : void 0;\r\n}\r\nexport function useRequestFetch() {\r\n  if (import.meta.client) {\r\n    return globalThis.$fetch;\r\n  }\r\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\r\n}\r\nexport function setResponseStatus(arg1, arg2, arg3) {\r\n  if (import.meta.client) {\r\n    return;\r\n  }\r\n  if (arg1 && typeof arg1 !== \"number\") {\r\n    return _setResponseStatus(arg1, arg2, arg3);\r\n  }\r\n  const event = useRequestEvent();\r\n  if (event) {\r\n    return _setResponseStatus(event, arg1, arg2);\r\n  }\r\n}\r\nexport function useResponseHeader(header) {\r\n  if (import.meta.client) {\r\n    if (import.meta.dev) {\r\n      return computed({\r\n        get: () => void 0,\r\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\r\n      });\r\n    }\r\n    return ref();\r\n  }\r\n  const event = useRequestEvent();\r\n  return computed({\r\n    get() {\r\n      return getResponseHeader(event, header);\r\n    },\r\n    set(newValue) {\r\n      if (!newValue) {\r\n        return removeResponseHeader(event, header);\r\n      }\r\n      return setResponseHeader(event, header, newValue);\r\n    }\r\n  });\r\n}\r\nexport function prerenderRoutes(path) {\r\n  if (!import.meta.server || !import.meta.prerender) {\r\n    return;\r\n  }\r\n  const paths = toArray(path);\r\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\r\n}\r\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\r\nexport function onPrehydrate(callback, key) {\r\n  if (import.meta.client) {\r\n    return;\r\n  }\r\n  if (typeof callback !== \"string\") {\r\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\r\n  }\r\n  const vm = getCurrentInstance();\r\n  if (vm && key) {\r\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\r\n    key = \":\" + key + \":\";\r\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\r\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\r\n    }\r\n  }\r\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\r\n  useHead({\r\n    script: [{\r\n      key: vm && key ? key : void 0,\r\n      tagPosition: \"bodyClose\",\r\n      tagPriority: \"critical\",\r\n      innerHTML: code\r\n    }]\r\n  });\r\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\r\n}\r\n","import { computed, reactive, toValue, watch } from \"vue\";\r\nimport { hash } from \"ohash\";\r\nimport { isPlainObject } from \"@vue/shared\";\r\nimport { useRequestFetch } from \"./ssr.js\";\r\nimport { useAsyncData } from \"./asyncData.js\";\r\nimport { alwaysRunFetchOnKeyChange, fetchDefaults } from \"#build/nuxt.config.mjs\";\r\nexport function useFetch(request, arg1, arg2) {\r\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\r\n  const _request = computed(() => toValue(request));\r\n  const key = computed(() => toValue(opts.key) || \"$f\" + hash([autoKey, typeof _request.value === \"string\" ? _request.value : \"\", ...generateOptionSegments(opts)]));\r\n  if (!opts.baseURL && typeof _request.value === \"string\" && (_request.value[0] === \"/\" && _request.value[1] === \"/\")) {\r\n    throw new Error('[nuxt] [useFetch] the request URL must not start with \"//\".');\r\n  }\r\n  const {\r\n    server,\r\n    lazy,\r\n    default: defaultFn,\r\n    transform,\r\n    pick,\r\n    watch: watchSources,\r\n    immediate,\r\n    getCachedData,\r\n    deep,\r\n    dedupe,\r\n    ...fetchOptions\r\n  } = opts;\r\n  const _fetchOptions = reactive({\r\n    ...fetchDefaults,\r\n    ...fetchOptions,\r\n    cache: typeof opts.cache === \"boolean\" ? void 0 : opts.cache\r\n  });\r\n  const _asyncDataOptions = {\r\n    server,\r\n    lazy,\r\n    default: defaultFn,\r\n    transform,\r\n    pick,\r\n    immediate,\r\n    getCachedData,\r\n    deep,\r\n    dedupe,\r\n    watch: watchSources === false ? [] : [...watchSources || [], _fetchOptions]\r\n  };\r\n  if (import.meta.dev) {\r\n    _asyncDataOptions._functionName ||= \"useFetch\";\r\n  }\r\n  if (alwaysRunFetchOnKeyChange && !immediate) {\r\n    let setImmediate = function() {\r\n      _asyncDataOptions.immediate = true;\r\n    };\r\n    watch(key, setImmediate, { flush: \"sync\", once: true });\r\n    watch([...watchSources || [], _fetchOptions], setImmediate, { flush: \"sync\", once: true });\r\n  }\r\n  let controller;\r\n  const asyncData = useAsyncData(watchSources === false ? key.value : key, () => {\r\n    controller?.abort?.(new DOMException(\"Request aborted as another request to the same endpoint was initiated.\", \"AbortError\"));\r\n    controller = typeof AbortController !== \"undefined\" ? new AbortController() : {};\r\n    const timeoutLength = toValue(opts.timeout);\r\n    let timeoutId;\r\n    if (timeoutLength) {\r\n      timeoutId = setTimeout(() => controller.abort(new DOMException(\"Request aborted due to timeout.\", \"AbortError\")), timeoutLength);\r\n      controller.signal.onabort = () => clearTimeout(timeoutId);\r\n    }\r\n    let _$fetch = opts.$fetch || globalThis.$fetch;\r\n    if (import.meta.server && !opts.$fetch) {\r\n      const isLocalFetch = typeof _request.value === \"string\" && _request.value[0] === \"/\" && (!toValue(opts.baseURL) || toValue(opts.baseURL)[0] === \"/\");\r\n      if (isLocalFetch) {\r\n        _$fetch = useRequestFetch();\r\n      }\r\n    }\r\n    return _$fetch(_request.value, { signal: controller.signal, ..._fetchOptions }).finally(() => {\r\n      clearTimeout(timeoutId);\r\n    });\r\n  }, _asyncDataOptions);\r\n  return asyncData;\r\n}\r\nexport function useLazyFetch(request, arg1, arg2) {\r\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\r\n  if (import.meta.dev) {\r\n    opts._functionName ||= \"useLazyFetch\";\r\n  }\r\n  return useFetch(\r\n    request,\r\n    {\r\n      ...opts,\r\n      lazy: true\r\n    },\r\n    // @ts-expect-error we pass an extra argument with the resolved auto-key to prevent another from being injected\r\n    autoKey\r\n  );\r\n}\r\nfunction generateOptionSegments(opts) {\r\n  const segments = [\r\n    toValue(opts.method)?.toUpperCase() || \"GET\",\r\n    toValue(opts.baseURL)\r\n  ];\r\n  for (const _obj of [opts.params || opts.query]) {\r\n    const obj = toValue(_obj);\r\n    if (!obj) {\r\n      continue;\r\n    }\r\n    const unwrapped = {};\r\n    for (const [key, value] of Object.entries(obj)) {\r\n      unwrapped[toValue(key)] = toValue(value);\r\n    }\r\n    segments.push(unwrapped);\r\n  }\r\n  if (opts.body) {\r\n    const value = toValue(opts.body);\r\n    if (!value) {\r\n      segments.push(hash(value));\r\n    } else if (value instanceof ArrayBuffer) {\r\n      segments.push(hash(Object.fromEntries([...new Uint8Array(value).entries()].map(([k, v]) => [k, v.toString()]))));\r\n    } else if (value instanceof FormData) {\r\n      const obj = {};\r\n      for (const entry of value.entries()) {\r\n        const [key, val] = entry;\r\n        obj[key] = val instanceof File ? val.name : val;\r\n      }\r\n      segments.push(hash(obj));\r\n    } else if (isPlainObject(value)) {\r\n      segments.push(hash(reactive(value)));\r\n    } else {\r\n      try {\r\n        segments.push(hash(value));\r\n      } catch {\r\n        console.warn(\"[useFetch] Failed to hash body\", value);\r\n      }\r\n    }\r\n  }\r\n  return segments;\r\n}\r\n","<template>\r\n  <section>\r\n    <div class=\"container my-4\">\r\n      <div class=\"row g-3 align-items-end\">\r\n        <div class=\"col-12\">\r\n          <h1 class=\"h3 mb-0\">Daftar KBLI</h1>\r\n          <p class=\"text-muted mb-0\">Pencarian dan filter Klasifikasi Baku Lapangan Usaha Indonesia (KBLI)</p>\r\n        </div>\r\n        <div class=\"col-12 col-md-8\">\r\n          <label for=\"kbliSearch\" class=\"form-label\">Cari</label>\r\n          <div class=\"input-group\">\r\n            <span class=\"input-group-text\"><i class=\"fas fa-search\"></i></span>\r\n            <input id=\"kbliSearch\" v-model=\"search\" type=\"text\" class=\"form-control\" placeholder=\"Cari kode, judul, atau uraian KBLI...\" />\r\n          </div>\r\n        </div>\r\n        <div class=\"col-12 col-md-4\">\r\n          <label for=\"kbliCat\" class=\"form-label\">Kategori</label>\r\n          <select id=\"kbliCat\" v-model=\"category\" class=\"form-select\">\r\n            <option value=\"\">Semua KBLI</option>\r\n            <option v-for=\"opt in categoryOptions\" :key=\"opt.value\" :value=\"opt.value\">\r\n              {{ opt.value }} — {{ opt.label }}\r\n            </option>\r\n          </select>\r\n        </div>\r\n      </div>\r\n\r\n      <div class=\"d-flex justify-content-between align-items-center mt-3\">\r\n        <small class=\"text-muted\">Menampilkan {{ displayStart.toLocaleString('id-ID') }}–{{ displayEnd.toLocaleString('id-ID') }} dari {{ totalItems.toLocaleString('id-ID') }} KBLI</small>\r\n        <div v-if=\"pending\" class=\"text-warning\"><i class=\"fa-solid fa-circle-notch fa-spin\"></i> Memuat data…</div>\r\n      </div>\r\n\r\n      <div v-if=\"error\" class=\"alert alert-danger mt-3\">\r\n        Terjadi kesalahan saat memuat data KBLI. Silakan coba lagi.\r\n      </div>\r\n\r\n      <div v-if=\"!pending && !error\" class=\"mt-3\">\r\n        <div v-if=\"filteredItems.length === 0\" class=\"alert alert-warning\">\r\n          Tidak ada hasil yang cocok.\r\n        </div>\r\n\r\n        <div v-else class=\"list-group\">\r\n          <article v-for=\"it in filteredItems\" :key=\"it.code\" class=\"list-group-item list-group-item-action\">\r\n            <div class=\"d-flex w-100 justify-content-between align-items-start\">\r\n              <h2 class=\"h6 mb-1\">\r\n                <span class=\"badge bg-primary me-2 fw-bold\">{{ it.code }}</span>\r\n                {{ it.title }}\r\n              </h2>\r\n              <span class=\"badge bg-dark-subtle text-dark\" v-if=\"it.section\">\r\n                {{ it.section }}\r\n              </span>\r\n            </div>\r\n            <p class=\"mb-0 text-muted\" style=\"white-space: pre-line\">{{ it.description }}</p>\r\n          </article>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </section>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { computed, ref, watch } from 'vue'\r\nimport { useFetch, useHead } from '#app'\r\n\r\nuseHead({\r\n  title: 'KBLI — RuangOffice',\r\n  meta: [\r\n    { name: 'description', content: 'Cari dan filter daftar KBLI (Klasifikasi Baku Lapangan Usaha Indonesia) berdasarkan kode, judul, dan uraian.' }\r\n  ]\r\n})\r\n\r\n// Category mapping based on first two digits of KBLI code\r\nconst SECTION_MAP: { range: [number, number] | number[]; section: string; label: string }[] = [\r\n  { range: [1, 3], section: 'A', label: 'Pertanian, Kehutanan, dan Perikanan' },\r\n  { range: [5, 9], section: 'B', label: 'Pertambangan dan Penggalian' },\r\n  { range: [10, 33], section: 'C', label: 'Industri Pengolahan' },\r\n  { range: [35, 35], section: 'D', label: 'Pengadaan Listrik, Gas, Uap/ Air Panas' },\r\n  { range: [36, 39], section: 'E', label: 'Pengadaan Air, Pengelolaan Sampah & Daur Ulang' },\r\n  { range: [41, 43], section: 'F', label: 'Konstruksi' },\r\n  { range: [45, 47], section: 'G', label: 'Perdagangan Besar dan Eceran; Reparasi Mobil & Motor' },\r\n  { range: [49, 53], section: 'H', label: 'Pengangkutan dan Pergudangan' },\r\n  { range: [55, 56], section: 'I', label: 'Penyediaan Akomodasi dan Makan Minum' },\r\n  { range: [58, 63], section: 'J', label: 'Informasi dan Komunikasi' },\r\n  { range: [64, 66], section: 'K', label: 'Jasa Keuangan dan Asuransi' },\r\n  { range: [68, 68], section: 'L', label: 'Real Estat' },\r\n  { range: [69, 75], section: 'M', label: 'Jasa Profesional, Ilmiah dan Teknis' },\r\n  { range: [77, 82], section: 'N', label: 'Jasa Persewaan, Ketenagakerjaan, Agen Perjalanan, dan Penunjang Usaha' },\r\n  { range: [84, 84], section: 'O', label: 'Administrasi Pemerintahan, Pertahanan dan Jaminan Sosial Wajib' },\r\n  { range: [85, 85], section: 'P', label: 'Pendidikan' },\r\n  { range: [86, 88], section: 'Q', label: 'Jasa Kesehatan dan Kegiatan Sosial' },\r\n  { range: [90, 93], section: 'R', label: 'Kesenian, Hiburan dan Rekreasi' },\r\n  { range: [94, 96], section: 'S', label: 'Kegiatan Jasa Lainnya' },\r\n  { range: [97, 98], section: 'T', label: 'Kegiatan Rumah Tangga Sebagai Pemberi Kerja' },\r\n  { range: [99, 99], section: 'U', label: 'Kegiatan Badan Internasional dan Ekstra Internasional' }\r\n]\r\n\r\nfunction getSection(code: string): string {\r\n  if (!code) return ''\r\n  const two = Number(code.slice(0, 2))\r\n  for (const m of SECTION_MAP) {\r\n    const [start, end] = m.range as [number, number]\r\n    if (two >= start && two <= end) return m.section\r\n  }\r\n  return ''\r\n}\r\n\r\nfunction getSectionLabel(section: string): string {\r\n  const found = SECTION_MAP.find(m => m.section === section)\r\n  return found ? found.label : ''\r\n}\r\n\r\nconst { data, pending, error } = await useFetch('/kbli.json', { default: () => [] as any[] })\r\n\r\n// Local reactive states\r\nconst search = ref('')\r\nconst category = ref('') // '' = All, otherwise 'A'..'U'\r\n\r\n// Build category options from map\r\nconst categoryOptions = computed(() => SECTION_MAP.map(m => ({ value: m.section, label: m.label })))\r\n\r\n// Enrich items with section computed\r\nconst items = computed(() => {\r\n  const arr: { code: string; title: string; description: string; section: string }[] = (data.value || []).map((it: any) => ({\r\n    code: it.code,\r\n    title: it.title,\r\n    description: it.description,\r\n    section: getSection(String(it.code || ''))\r\n  }))\r\n  return arr\r\n})\r\n\r\nconst normalized = (s: string) => (s || '').toLowerCase()\r\n\r\nconst filteredItems = computed(() => {\r\n  const q = normalized(search.value)\r\n  const cat = category.value\r\n  return items.value.filter(it => {\r\n    if (cat && it.section !== cat) return false\r\n    if (!q) return true\r\n    return (\r\n      normalized(it.code).includes(q) ||\r\n      normalized(it.title).includes(q) ||\r\n      normalized(it.description).includes(q)\r\n    )\r\n  })\r\n})\r\n</script>\r\n\r\n<style scoped>\r\n.bg-dark-subtle {\r\n  background-color: rgba(0,0,0,.075);\r\n}\r\n</style>\r\n"],"version":3}